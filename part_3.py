#!/usr/bin/env python
"""Provides dijkstra, a method for graphs.

Dijkstra's algorithm finds the shortest cost path between vertices (s, t) on a weighted, non-cyclic, regular (directed or undirected) graph
"""

import errors

import heapq


def dijkstra(graph, source, dest):
    """
    Given a graph, source, dest, return the path of least cost between the source and dest

    * assumes the graph is a correct defaultdict generated by graph_utils.py's "make_graph"

    Args:
        graph: the standard graph defaultdict that represents vertices and edges (see graph.py)
        source: a string, representing the source vertex in the graph
        dest: a string, representing the terminal vertex in the graph

    Returns:
        The (path of the least-cost route, cost of the route cost), or 'NO SUCH ROUTE' if it doesn't exist

    Raises:
        DoesNotExistError: If the source or dest strings don't exist in the graph
    """

    ''' ERROR HANDLING '''
    # make sure the vertices exist in the graph
    for vertex in [source, dest]:
        if vertex not in [v for (v, tuple) in graph.iteritems()]:
            raise errors.DoesNotExistError('"{0}" does not exist as a connected vertex in the graph'.format(vertex))

    # priority queue, composed of tuples of (cost, source, path)
    q = []

    # keeps track of the visited nodes
    seen = set()

    # however, if the source is terminal already, we don't want to return 0
    # we avoid this by adding neighbouring vertices to priority queue
    if source == dest:
        for (v2, cost) in graph.get(source):
            heapq.heappush(q, (0+cost, v2, [source]))

    else: # otherwise, we begin with 0 cost, graph source, no path
        heapq.heappush(q, (0, source, []))

    while q: # while there are elements in the priority queue
        (cost,v1,path) = heapq.heappop(q) # get the least cost path so far in the heap

        if v1 not in seen: # if we haven't visited v1 yet
            seen.add(v1) # consider v1 as visited

            # add the node to the end of the path
            path = path + [v1]
            if v1 == dest: 
                return (path, cost)

            # for adjacent nodes, add them to the priority queue 
            for (v2, c) in graph.get(v1, ()):
                if v2 not in seen: # as long as they haven't been visited already
                    heapq.heappush(q, (cost+c, v2, path))

    # there isn't a solution
    return 'NO SUCH ROUTE'
