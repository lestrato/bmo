#!/usr/bin/env python
"""Provides get_bfs_paths (a method for graphs), and get_num_bfs_paths (a wrapper for get_bfs_paths)

get_bfs_paths finds all paths between a source and a terminal on an unweighted graph using BFS,get_num_bfs_paths
get_num_bfs_paths gets the number of lists (less than/greater than/equal to) a given size
"""

import errors

import heapq

def get_bfs_paths(graph, source, dest):
    """
    Given a graph, source, dest, return the paths and costs between a source and terminal using a modified version of BFS

    * assumes all inputs are correct, since this is only called in get_num_bfs_paths

    Args:
        graph: the standard graph defaultdict that represents vertices and edges (see graph.py)
        source: a string, representing the source vertex in the graph
        dest: a string, representing the terminal vertex in the graph

    Retruns:
        The paths between a source and terminal, set of tuples ((path tuple), cost of path)

    """

    # priority queue, composed of tuples (v1, [list of adjacent v's to v1])
    q = []

    # however, if the source is terminal already, we don't want to return 0 and no paths found
    # we avoid this by adding starting BFS from each neighbouring vertex to the source, ending at the source,
    # then adding the source at the beginning of the path and adding the cost form the source to the neighbour to the path cost
    if source == dest:
        bfs_paths = set()
        for (v2, c) in graph[source]:
            for (path, cost) in get_bfs_paths(graph, v2, source):
                bfs_paths.add(((tuple([source] + [town for town in path])), cost+c) )
        return bfs_paths

    else: # otherwise, we begin with the graph source, connected to itself as a destination
        heapq.heappush(q, (0, source, [source]))

    bfs_paths = []
    # when we reach this it'll be the base case and our way out of the while loop
    while q:
        # get the cost, the next unvisited vertex in the queue, and the path so far
        (cost, v1, path) = heapq.heappop(q)

        frontier_vertices = set([v2 for v2, c in graph[v1]]) - set(path) # get the adjacent vertices we haven't been to yet

        # go to each adjacent vertex (v2) that isn't in the path already (i.e. so no loops are made)
        for (v2, c) in graph.get(v1, ()):
            if v2 in frontier_vertices:
                if v2 == dest:
                    bfs_paths.append((path + [v2], cost+c))
                else:
                    heapq.heappush(q, (cost+c, v2, path + [v2]))

    return set([(tuple(bfs_path), cost) for (bfs_path, cost) in bfs_paths])


def get_num_bfs_paths(graph, source, dest, filter_type, operator, value):
    """
    Given a graph, source, dest, operator, and value, return the number of paths between a source and terminal as long as they follow their path [filter_type = (vertex count/total cost)] is [operator = (less than/greater than/equal to)] a value.

    * assumes the graph is a correct defaultdict generated by graph_utils.py's "make_graph"

    Args:
        graph: the standard graph defaultdict that represents vertices and edges (see graph.py)
        source: a string, representing the source vertex in the graph
        dest: a string, representing the terminal vertex in the graph
        filter_type: a string in ['towns', 'distance'], used in relation with..
        operator: a string in ['less_than', 'more_than', 'equal_to'], used in relation with..
        value: an int, greater than or equal to 0.

    Returns:
        The number of paths between a source and terminal as long as they follow that their path [filter_type = (vertex count/total cost)] is [operator = (less than/greater than/equal to)] a value.

    Raises:
        DoesNotExistError: If the source or dest strings don't exist in the graph
        ValueError: If the operator filter_type is not in ['towns', 'distance']
        ValueError: If the operator param is not in ['less_than', 'more_than', 'equal_to']
        ValueError: If the value param is not a non-negative integer
    """

    ''' ERROR HANDLING '''
    # make sure the vertices exist in the graph
    for vertex in [source, dest]:
        if vertex not in [v for (v, tuple) in graph.iteritems()]:
            raise errors.DoesNotExistError('"{0}" does not exist as a connected vertex in the graph'.format(vertex))

    accepted_filter_type = ['towns', 'distance']
    if filter_type not in accepted_filter_type:
        raise ValueError("Unknown filter type, accepted filter types are: {0}".format(accepted_filter_type))

    accepted_operators = ['less_than', 'more_than', 'equal_to']
    if operator not in accepted_operators:
        raise ValueError("Unknown operator, accepted operators are: {0}".format(accepted_operators))

    try:
        if float(value) != int(value) or int(value) < 0: raise ValueError
        value = int(value)
    except ValueError:
        raise ValueError("The value passed must be an integer, greater than or equal to 0")

    ''' FIND ALL PATHS BETWEEN SOURCE AND TERMINAL BETWEEN S AND T '''
    bfs_paths = get_bfs_paths(graph, source, dest)

    ''' OUT OF THE ABOVE PATHS, FIND HOW MANY ADHERE TO THE FILTERTYPE, OPERATOR AND VALUE GIVEN '''
    if filter_type == 'towns':
        bfs_paths = [bfs_path[0] for bfs_path in bfs_paths]
        return len([bfs_path for bfs_path in bfs_paths if (operator == 'less_than' and len(bfs_path) - 1 < value) or (operator == 'more_than' and len(bfs_path) - 1 > value) or (operator == 'equal_to' and len(bfs_path) - 1 == value)])
    elif filter_type == 'distance':
        bfs_paths = [bfs_path[1] for bfs_path in bfs_paths]
        return len([bfs_path for bfs_path in bfs_paths if (operator == 'less_than' and bfs_path < value) or (operator == 'more_than' and bfs_path > value) or (operator == 'equal_to' and bfs_path == value)])
